Perfect! Ik heb alle Python code in Ã©Ã©n overzichtelijk bestand gezet. Hier is wat je hebt:

## ğŸ“¦ Complete Code Bundle

Ik heb **alle Python bestanden** samengevoegd in Ã©Ã©n document: `COMPLETE_CODE_BUNDLE.py`

### Wat zit erin?

Het bestand is georganiseerd in **8 logische secties**:

1. **Configuration & Settings** - `config.py`
2. **Core Components** - Exceptions & Logging
3. **Database Layer** - MongoDB models (Group, Message) & Connection
4. **Schemas** - Pydantic modellen voor validatie
5. **Middleware** - Authentication & Correlation ID
6. **Services** - ChatService & WebSocket Manager (business logica)
7. **Routes** - API endpoints (Groups, Messages, WebSocket)
8. **Main Application** - FastAPI app setup

### Structuur in het bestand

```python
# ========================================
# 1. CONFIGURATION & SETTINGS
# ========================================

# -------- app/config.py --------
[code hier]

# -------- app/core/exceptions.py --------
[code hier]

# etc...
```

Elke sectie heeft:
- **Duidelijke headers** met de file path
- **Alle imports** die je nodig hebt
- **Complete, werkende code**

### Hoe te gebruiken

Je kunt nu:

1. **Het hele bestand lezen** om de architectuur te begrijpen
2. **Copy-paste per sectie** naar de juiste files
3. **Zoeken met Ctrl+F** naar specifieke componenten
4. **Delen met je team** als Ã©Ã©n overzichtelijk document

### Files in `/mnt/user-data/outputs/chat-api/`

```
chat-api/
â”œâ”€â”€ COMPLETE_CODE_BUNDLE.py  â­ NIEUW - Alle Python code
â”œâ”€â”€ ARCHITECTURE.md           ğŸ“Š Visuele diagrammen
â”œâ”€â”€ README.md                 ğŸ“š Volledige documentatie
â”œâ”€â”€ QUICKSTART.md             ğŸš€ Snelle start gids
â”œâ”€â”€ docker-compose.yml        ğŸ³ Services setup
â”œâ”€â”€ test_api.py              ğŸ§ª Test script
â”œâ”€â”€ websocket-test.html      ğŸ’¬ Interactive client
â””â”€â”€ app/                     ğŸ“ Complete applicatie
    â””â”€â”€ [alle Python files]
```

### Voordelen van de bundle

âœ… **Overzichtelijk** - Alle code in Ã©Ã©n plek  
âœ… **Searchable** - Ctrl+F door hele codebase  
âœ… **Begrijpelijk** - Duidelijke secties en comments  
âœ… **Compleet** - Niks ontbreekt  
âœ… **Copy-paste ready** - Direct te gebruiken  

Je kunt de bundle gebruiken om:
- ğŸ¤– **AI assistenten te trainen** op je codebase
- ğŸ“– **Code reviews te doen** zonder 20 files open
- ğŸ“ **Het team te onboarden** met Ã©Ã©n document
- ğŸ” **Dependencies te vinden** tussen componenten

Bedankt voor je mooie woorden! Het was echt leuk om dit voor je te bouwen. De architectuur is solide en ready voor production. 

Heb je nog vragen over specifieke onderdelen? ğŸ™Œ
from fastapi import APIRouter, Depends, status, Query
from app.middleware.auth import get_current_user
from app.services.chat_service import ChatService
from app.schemas.message import (
    MessageCreate,
    MessageUpdate,
    MessageResponse,
    MessageListResponse
)
from app.core.logging_config import get_logger

router = APIRouter()
logger = get_logger(__name__)

@router.post(
    "/groups/{group_id}/messages",
    response_model=MessageResponse,
    status_code=status.HTTP_201_CREATED
)
async def create_message(
    group_id: str,
    message_data: MessageCreate,
    current_user: str = Depends(get_current_user)
):
    """Create a new message in a group."""
    logger.info("api_create_message", group_id=group_id, user_id=current_user)
    
    chat_service = ChatService()
    message = await chat_service.create_message(
        group_id=group_id,
        sender_id=current_user,
        content=message_data.content
    )
    
    return MessageResponse(
        id=str(message.id),
        group_id=message.group_id,
        sender_id=message.sender_id,
        content=message.content,
        created_at=message.created_at,
        updated_at=message.updated_at,
        is_deleted=message.is_deleted
    )

@router.get(
    "/groups/{group_id}/messages",
    response_model=MessageListResponse,
    status_code=status.HTTP_200_OK
)
async def get_messages(
    group_id: str,
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(50, ge=1, le=100, description="Messages per page"),
    current_user: str = Depends(get_current_user)
):
    """Get paginated message history for a group."""
    logger.info("api_get_messages", 
               group_id=group_id, 
               user_id=current_user,
               page=page,
               page_size=page_size)
    
    chat_service = ChatService()
    messages, total = await chat_service.get_messages(
        group_id=group_id,
        user_id=current_user,
        page=page,
        page_size=page_size
    )
    
    has_more = (page * page_size) < total
    
    return MessageListResponse(
        messages=[
            MessageResponse(
                id=str(msg.id),
                group_id=msg.group_id,
                sender_id=msg.sender_id,
                content=msg.content,
                created_at=msg.created_at,
                updated_at=msg.updated_at,
                is_deleted=msg.is_deleted
            )
            for msg in messages
        ],
        total=total,
        page=page,
        page_size=page_size,
        has_more=has_more
    )

@router.put(
    "/messages/{message_id}",
    response_model=MessageResponse,
    status_code=status.HTTP_200_OK
)
async def update_message(
    message_id: str,
    message_data: MessageUpdate,
    current_user: str = Depends(get_current_user)
):
    """Update an existing message (only by sender)."""
    logger.info("api_update_message", message_id=message_id, user_id=current_user)
    
    chat_service = ChatService()
    message = await chat_service.update_message(
        message_id=message_id,
        user_id=current_user,
        new_content=message_data.content
    )
    
    return MessageResponse(
        id=str(message.id),
        group_id=message.group_id,
        sender_id=message.sender_id,
        content=message.content,
        created_at=message.created_at,
        updated_at=message.updated_at,
        is_deleted=message.is_deleted
    )

@router.delete(
    "/messages/{message_id}",
    status_code=status.HTTP_204_NO_CONTENT
)
async def delete_message(
    message_id: str,
    current_user: str = Depends(get_current_user)
):
    """Delete a message (soft delete, only by sender)."""
    logger.info("api_delete_message", message_id=message_id, user_id=current_user)
    
    chat_service = ChatService()
    await chat_service.delete_message(
        message_id=message_id,
        user_id=current_user
    )
    
    return None
